# unity_socket_main.py
"""
Unity socket bridge (cleaned for current Unity front-end)
- Removes legacy town map & Gradio UI
- Uses current scene/building/portal names:
  Apartment_F1 / Apartment_F2 / School / Rest / Gym / Super / Subway / Exterior
- "Apartment" target defaults to F1
- Safe LLM loader to avoid OllamaAgent __init__ arg mismatch during import
"""

import argparse
import asyncio
import json
import logging
import math
import os
import random
import socket
import time
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional, Tuple

import numpy as np
from sklearn.cluster import DBSCAN

# ---------------------------
# Logging
# ---------------------------
logging.basicConfig(level=logging.INFO, format='[%(levelname)s] %(message)s')
logger = logging.getLogger("unity_socket")
MOVEMENT_MANAGER: Optional["MovementController"] = None  # Forward declaration placeholder

# ---------------------------
# Unity socket config
# ---------------------------
UNITY_IP = "127.0.0.1"
UNITY_PORT = 12345
UI_SOCKET_AVAILABLE = True

# ---------------------------
# Current Unity scene markers (anchors) & portals
# ---------------------------
UNITY_LOCATION_MARKERS: Dict[str, Dict[str, Any]] = {
    "Apartment_F1": {"anchor": (-83.5, -50.6), "aliases": ["Apartment", "ÂÖ¨ÂØì", "ÂÖ¨ÂØì‰∏ÄÊ®ì", "ÂÖ¨ÂØìF1"]},
    "Apartment_F2": {"anchor": (-184.7, -57.0), "aliases": ["ÂÖ¨ÂØì‰∫åÊ®ì", "Apartment_Floor2"]},
    "School":       {"anchor": (-1.0, -109.7), "aliases": ["Â≠∏Ê†°", "ÊïôÂÆ§", "Ê†°Âúí", "Ê†°Âõ≠"]},
    "Rest":         {"anchor": (-98.0, 10.5),   "aliases": ["È§êÂª≥", "È§êÂéÖ", "ÂíñÂï°Â∫ó", "Cafe", "Restaurant"]},
    "Gym":          {"anchor": (-86.8, 42.9),   "aliases": ["ÂÅ•Ë∫´Êàø", "Gymnasium"]},
    "Super":        {"anchor": (52.2, 92.9),    "aliases": ["Ë∂ÖÂ∏Ç", "ÂïÜÂ†¥", "ÂïÜÂú∫", "‰æøÂà©Â∫ó"]},
    "Subway":       {"anchor": (166.7, -97.1),  "aliases": ["Âú∞Èêµ", "Âú∞ÈìÅ", "Metro"]},
    "Exterior":     {"anchor": (174.8, 1.9),    "aliases": ["ÂÆ§Â§ñ", "Êà∂Â§ñ", "Êà∑Â§ñ", "ÂÖ¨Âúí", "Park"]},
}

# Apartment Âà•ÂêçÈ†êË®≠Â∞éÂêë F1
PORTAL_NAME_ALIASES = {
    "ÂÖ¨ÂØì": "Apartment_F1",
    "ÂÖ¨ÂØìF1": "Apartment_F1",
    "ÂÖ¨ÂØìF2": "Apartment_F2",
    "Apartment": "Apartment_F1",
    "Apartment_Floor2": "Apartment_F2",
    "ÂÖ¨ÂØì‰∫åÊ®ì": "Apartment_F2",
    "ÂÖ¨ÂØì‰∏ÄÊ®ì": "Apartment_F1",
}

RAW_PORTAL_MARKERS: List[Dict[str, Any]] = [
    {"name": "ÂÅ•Ë∫´Êàø_ÂÆ§ÂÖß", "position": (-66.92, 17.73), "targets": ["ÂÅ•Ë∫´Êàø_ÂÆ§Â§ñ"]},
    {"name": "ÂÅ•Ë∫´Êàø_ÂÆ§Â§ñ", "position": (97.5, 15.17), "targets": ["ÂÅ•Ë∫´Êàø_ÂÆ§ÂÖß"]},
    {"name": "ÂÖ¨ÂØì‰∏ÄÊ®ì_ÂÆ§ÂÖß", "position": (-67.92, -13.82), "targets": ["ÂÖ¨ÂØì‰∫åÊ®ì_ÂÆ§ÂÖß"]},
    {"name": "ÂÖ¨ÂØì‰∫åÊ®ì_ÂÆ§ÂÖß", "position": (-117.08, -46.82), "targets": ["ÂÖ¨ÂØìÈ†ÇÊ®ì_ÂÆ§ÂÖß", "ÂÖ¨ÂØì‰∏ÄÊ®ì_ÂÆ§ÂÖß"]},
    {"name": "ÂÖ¨ÂØìÂÅ¥ÈñÄ_ÂÆ§ÂÖß", "position": (-57.92, -44.995003), "targets": ["ÂÖ¨ÂØìÂÅ¥ÈñÄ_ÂÆ§Â§ñ"]},
    {"name": "ÂÖ¨ÂØìÂÅ¥ÈñÄ_ÂÆ§Â§ñ", "position": (6.06, -10.34), "targets": ["ÂÖ¨ÂØìÂÅ¥ÈñÄ_ÂÆ§ÂÖß"]},
    {"name": "ÂÖ¨ÂØìÂ§ßÈñÄ_ÂÆ§ÂÖß", "position": (-77.008, -44.995003), "targets": ["ÂÖ¨ÂØìÂ§ßÈñÄ_ÂÆ§Â§ñ"]},
    {"name": "ÂÖ¨ÂØìÂ§ßÈñÄ_ÂÆ§Â§ñ", "position": (-3.4, -9.01), "targets": ["ÂÖ¨ÂØìÂ§ßÈñÄ_ÂÆ§ÂÖß"]},
    {"name": "ÂÖ¨ÂØìÈ†ÇÊ®ì_ÂÆ§ÂÖß", "position": (-117.08, -13.62), "targets": ["ÂÖ¨ÂØìÈ†ÇÊ®ì_ÂÆ§Â§ñ", "ÂÖ¨ÂØì‰∫åÊ®ì_ÂÆ§ÂÖß"]},
    {"name": "ÂÖ¨ÂØìÈ†ÇÊ®ì_ÂÆ§Â§ñ", "position": (-2.4, 4.42), "targets": ["ÂÖ¨ÂØìÈ†ÇÊ®ì_ÂÆ§ÂÖß"]},
    {"name": "Âú∞Èêµ‰∏äÂÖ•Âè£_ÂÆ§Â§ñ", "position": (42.46, -30.38), "targets": ["Âú∞ÈêµÂ∑¶Ê®ìÊ¢Ø_ÂÆ§ÂÖß"]},
    {"name": "Âú∞Èêµ‰∏ãÂÖ•Âè£_ÂÆ§Â§ñ", "position": (42.46, -36.45), "targets": ["Âú∞ÈêµÂè≥Ê®ìÊ¢Ø_ÂÆ§ÂÖß"]},
    {"name": "Âú∞ÈêµÂè≥ÂÖ•Âè£_ÂÆ§Â§ñ", "position": (45.46, -33.47), "targets": ["Âú∞ÈêµÂè≥Ê®ìÊ¢Ø_ÂÆ§ÂÖß"]},
    {"name": "Âú∞ÈêµÂè≥Ê®ìÊ¢Ø_ÂÆ§ÂÖß", "position": (78.03999, -32.58), "targets": ["Âú∞ÈêµÂè≥ÂÖ•Âè£_ÂÆ§Â§ñ", "Âú∞Èêµ‰∏ãÂÖ•Âè£_ÂÆ§Â§ñ"]},
    {"name": "Âú∞ÈêµÂ∑¶ÂÖ•Âè£_ÂÆ§Â§ñ", "position": (39.4, -33.5), "targets": ["Âú∞ÈêµÂ∑¶Ê®ìÊ¢Ø_ÂÆ§ÂÖß"]},
    {"name": "Âú∞ÈêµÂ∑¶Ê®ìÊ¢Ø_ÂÆ§ÂÖß", "position": (55.970005, -48.980003), "targets": ["Âú∞ÈêµÂ∑¶ÂÖ•Âè£_ÂÆ§Â§ñ", "Âú∞Èêµ‰∏äÂÖ•Âè£_ÂÆ§Â§ñ"]},
    {"name": "Â≠∏Ê†°ÈñÄÂè£_ÂÆ§ÂÖß", "position": (-26.504, -63.017), "targets": ["Â≠∏Ê†°ÈñÄÂè£_ÂÆ§Â§ñ"]},
    {"name": "Â≠∏Ê†°ÈñÄÂè£_ÂÆ§Â§ñ", "position": (106.4, -33.0), "targets": ["Â≠∏Ê†°ÈñÄÂè£_ÂÆ§ÂÖß"]},
    {"name": "Ë∂ÖÂ∏ÇÂÅ¥ÈñÄ_ÂÆ§ÂÖß", "position": (8.98, 55.15), "targets": ["Ë∂ÖÂ∏ÇÂÅ¥ÈñÄ_ÂÆ§Â§ñ"]},
    {"name": "Ë∂ÖÂ∏ÇÂÅ¥ÈñÄ_ÂÆ§Â§ñ", "position": (12.1, 19.830002), "targets": ["Ë∂ÖÂ∏ÇÂÅ¥ÈñÄ_ÂÆ§ÂÖß"]},
    {"name": "Ë∂ÖÂ∏ÇÂè≥ÈñÄ_ÂÆ§ÂÖß", "position": (5.98, 38.07), "targets": ["Ë∂ÖÂ∏ÇÂè≥ÈñÄ_ÂÆ§Â§ñ"]},
    {"name": "Ë∂ÖÂ∏ÇÂ∑¶ÈñÄ_ÂÆ§ÂÖß", "position": (-3.91, 38.07), "targets": ["Ë∂ÖÂ∏ÇÂ∑¶ÈñÄ_ÂÆ§Â§ñ"]},
    {"name": "Ë∂ÖÂ∏ÇÂ∑¶ÈñÄ_ÂÆ§Â§ñ", "position": (1.87, 15.88), "targets": ["Ë∂ÖÂ∏ÇÂ∑¶ÈñÄ_ÂÆ§ÂÖß"]},
    {"name": "Ë∂ÖÂ∏ÇÂ∑¶ÈñÄ_ÂÆ§Â§ñ", "position": (8.03, 15.88), "targets": ["Ë∂ÖÂ∏ÇÂ∑¶ÈñÄ_ÂÆ§ÂÖß"]},
    {"name": "È§êÂª≥_ÂÆ§ÂÖß", "position": (-73.00139, 0.972929), "targets": ["È§êÂª≥_ÂÆ§Â§ñ"]},
    {"name": "È§êÂª≥_ÂÆ§Â§ñ", "position": (96.95, -5.1), "targets": ["È§êÂª≥_ÂÆ§ÂÖß"]},
]

def _build_coordinate_lookup():
    coordinate_map: Dict[str, Any] = {}
    alias_map: Dict[str, str] = {}

    # ‰∏ªÂú∞Èªû anchors
    for name, meta in UNITY_LOCATION_MARKERS.items():
        anchor = meta.get("anchor")
        if anchor:
            coordinate_map[name] = (float(anchor[0]), float(anchor[1]))
        for alias in meta.get("aliases", []):
            alias_map[alias] = name

    # ÂÇ≥ÈÄÅÈñÄ
    portal_map: Dict[str, Dict[str, Any]] = {}
    for entry in RAW_PORTAL_MARKERS:
        pos = entry["position"]
        anchor = (round(float(pos[0]), 4), round(float(pos[1]), 4))
        payload = portal_map.setdefault(entry["name"], {"anchors": [], "targets": set()})
        if anchor not in payload["anchors"]:
            payload["anchors"].append(anchor)
        payload["targets"].update(entry.get("targets", []))

    # Âà•Âêç
    for alias, canonical in PORTAL_NAME_ALIASES.items():
        alias_map[alias] = canonical

    # Êï¥ÁêÜ portal anchors Ëàá alias Â∞çÊáâ
    for name, payload in portal_map.items():
        anchors = payload["anchors"]
        coordinate_map[name] = anchors[0] if len(anchors) == 1 else anchors
        payload["targets"] = sorted(payload["targets"])

    for alias, canonical in alias_map.items():
        if canonical in coordinate_map:
            coordinate_map[alias] = coordinate_map[canonical]

    return coordinate_map, portal_map

COORDINATE_MAP, UNITY_PORTAL_MARKERS = _build_coordinate_lookup()
CAN_GO_PLACES: List[str] = list(UNITY_LOCATION_MARKERS.keys())

ENVIRONMENT_OBJECTS = {
    "Apartment_F1": ["Â∫ä", "Ê≤ôÁôº", "Êõ∏Ê°å"],
    "Apartment_F2": ["Â∫ä", "Êõ∏Êû∂", "ÈôΩÂè∞Ê§Ö"],
    "School": ["ÈªëÊùø", "Ë™≤Ê°åÊ§Ö", "Ë¨õÂè∞"],
    "Rest": ["ÂíñÂï°Ê©ü", "ÁîúÈªûÊ´É", "Ê≤ôÁôºÊ§Ö"],
    "Gym": ["ÂïûÈà¥", "Ë∑ëÊ≠•Ê©ü", "ÁëúÁèàÂ¢ä"],
    "Super": ["Ë≤®Êû∂", "Êî∂ÈäÄÂè∞", "Ë≥ºÁâ©Á±É"],
    "Subway": ["ÂîÆÁ•®Ê©ü", "ÂÄôËªäÊ§Ö", "Ë∑ØÁ∑öÂúñ"],
    "Exterior": ["Èï∑Ê§Ö", "Ë∑ØÁáà", "ÂÖ¨Âúí"],
}
ACTION_EMOJI = {
    "Áù°Ë¶∫": "üò¥",
    "‰ºëÊÅØ": "üõãÔ∏è",
    "ÂêÉÈ£Ø": "üçï",
    "ËÅäÂ§©": "üí¨",
    "Â∑•‰Ωú": "üíº",
    "Â≠∏Áøí": "üìö",
    "ÈÜí‰æÜ": "‚òÄÔ∏è",
    "ÊÑèË≠ò‰∏çÊòé": "üòµ",
    "ÂàùÂßãÂåñ‰∏≠": "‚è≥",
    "ÁßªÂãï‰∏≠": "üëü",
}

ACTION_KEYWORDS: Dict[str, List[str]] = {
    "Áù°Ë¶∫": ["Áù°Ë¶∫", "Áù°Ëßâ", "sleep", "Â∞±ÂØù", "ÊâìÁõπ", "nap", "‰ºëÁú†"],
    "‰ºëÊÅØ": ["‰ºëÊÅØ", "relax", "ÊîæÈ¨Ü", "ÊîæÊùæ", "Ê≠áÊÅØ", "idle", "Á©∫Ê™î", "ÊîæÁ©∫"],
    "ÂêÉÈ£Ø": ["ÂêÉÈ£Ø", "ÂêÉÈ•≠", "Áî®È§ê", "È§ê", "Êó©È§ê", "ÂçàÈ§ê", "ÊôöÈ§ê", "ÂÆµÂ§ú", "lunch", "dinner", "breakfast", "meal", "Áî®ËÜ≥", "ÈÄ≤È§ê", "Â∞±È§ê", "È£≤È£ü"],
    "ËÅäÂ§©": ["ËÅäÂ§©", "‰∫§Ë´á", "Â∞çË©±", "‰∫§ÊµÅ", "ËÅä", "Ë´áË©±", "conversation", "chat", "Ê∫ùÈÄö", "ÈñíËÅä", "Âêå‰∫ã‰∫§ÊµÅ", "ÂØíÊöÑ"],
    "Â∑•‰Ωú": ["Â∑•‰Ωú", "‰∏äÁè≠", "Ëæ¶ÂÖ¨", "ÂäûÂÖ¨", "meeting", "ÈñãÊúÉ", "Âçî‰Ωú", "ÂØ´Â†±Âëä", "task", "office", "ÂãûÂãï", "labor", "ÊøÄÂãµÂêå‰∫ã", "ÂÄºÁè≠", "ÊúçÂãô"],
    "Â≠∏Áøí": ["Â≠∏Áøí", "Â≠¶‰π†", "‰∏äË™≤", "Ë™≤Á®ã", "ËÆÄÊõ∏", "study", "learn", "lecture", "reading", "ÊïôÂ≠∏", "ÂÇôË™≤", "Ë™≤Â†Ç", "Á†îËÆÄ"],
    "ÈÜí‰æÜ": ["ÈÜí", "ÈÜí‰æÜ", "ÈÜíÊù•", "Ëµ∑Â∫ä", "wake", "Ëµ∑Ë∫´", "ËòáÈÜí", "ËãèÈÜí", "Êó©Ëµ∑", "Ëµ∑Â∫äËôü", "rise"],
    "ÊÑèË≠ò‰∏çÊòé": ["ÊòèËø∑", "Êöà", "Êôï", "ÊöàÂÄí", "ÊòèÂé•", "Â§±Á•û", "Ëø∑Á≥ä", "Ê∑∑‰∫Ç", "confused", "unconscious", "dazed"],
    "ÂàùÂßãÂåñ‰∏≠": ["ÂàùÂßãÂåñ", "loading", "ÂïüÂãï", "ÂêØÂä®", "Ê∫ñÂÇô", "ÂáÜÂ§á", "start", "Á≠âÂæÖ", "ÊéíÈöä", "boot", "setup", "ÂïüÂãï‰∏≠", "ËºâÂÖ•", "load"],
    "ÁßªÂãï‰∏≠": ["ÁßªÂãï", "ÁßªÂä®", "Ë°åËµ∞", "Ëµ∞Ë∑Ø", "ÂâçÂæÄ", "Ë∂ïÂæÄ", "travel", "commute", "Ë∂ïË∑Ø", "Ë∑Ø‰∏ä", "Ë∂ïÂéª", "Â•îË∑ë", "ËΩâÁßª", "Âá∫Áôº", "Âá∫Âèë", "Ë∂ïËµ¥", "ÂâçÂéª", "Êê≠Ëªä", "‰πòËªä", "ÈÄöÂã§"],
}


def classify_activity(raw: str) -> Tuple[str, str]:
    if not raw:
        return "ÂàùÂßãÂåñ‰∏≠", ACTION_EMOJI["ÂàùÂßãÂåñ‰∏≠"]

    candidate = raw.strip()
    lowered = candidate.lower()

    for canonical, emoji in ACTION_EMOJI.items():
        if canonical and canonical in candidate:
            return canonical, emoji

    for canonical, keywords in ACTION_KEYWORDS.items():
        for keyword in keywords:
            if keyword.lower() in lowered or keyword in candidate:
                return canonical, ACTION_EMOJI[canonical]

    return "ÊÑèË≠ò‰∏çÊòé", ACTION_EMOJI["ÊÑèË≠ò‰∏çÊòé"]
# ---------------------------
# Default agents (names = MBTI / or your own agent folder names)
# ---------------------------
DEFAULT_AGENT_ORDER = ["ISTJ", "ISFJ", "INFJ"]
DEFAULT_AGENT_HOMES = {"ISTJ": "Apartment_F1", "ISFJ": "Apartment_F1", "INFJ": "Apartment_F2"}

# ---------------------------
# Unity TCP helpers
# ---------------------------
def send_move_command(ip: str, port: int, object_positions: List[Tuple[int, float, float]], delay: float = 0.5):
    try:
        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client.connect((ip, port))
        command = "MOVE:" + ";".join([f"{oid},{x},{y}" for oid, x, y in object_positions])
        client.sendall(command.encode("utf-8"))
        logger.debug("Sent: %s", command)
        client.close()
        if delay > 0:
            time.sleep(delay)
    except Exception as e:
        logger.error("send_move_command error: %s", e)

async def send_move_command_async(ip: str, port: int, object_positions: List[Tuple[int, float, float]], delay: float = 0.5):
    if not object_positions:
        return
    await asyncio.to_thread(send_move_command, ip, port, object_positions, delay)


class MovementController:
    def __init__(self, ip: str, port: int, agents: List["Agent"], step_delay: float = 0.55, idle_delay: float = 0.2):
        self.ip = ip
        self.port = port
        self._agents = agents
        self.step_delay = step_delay
        self.idle_delay = idle_delay
        self._stop_event = asyncio.Event()
        self._trigger_event = asyncio.Event()

    @property
    def agents(self) -> List["Agent"]:
        return self._agents

    @agents.setter
    def agents(self, value: List["Agent"]):
        self._agents = value
        self.request_push()

    def request_push(self):
        self._trigger_event.set()

    async def stop(self):
        self._stop_event.set()
        self._trigger_event.set()

    async def run(self):
        try:
            while not self._stop_event.is_set():
                try:
                    await asyncio.wait_for(self._trigger_event.wait(), timeout=self.idle_delay)
                except asyncio.TimeoutError:
                    pass
                self._trigger_event.clear()
                await self._flush_paths()
        finally:
            await self._flush_paths(force=True)

    async def _flush_paths(self, force: bool = False):
        agents = self._agents
        if not agents:
            return

        sent_any = False
        while True:
            step_batch: List[Tuple[int, float, float]] = []
            for agent in agents:
                if getattr(agent, "is_thinking", False) and not agent.walk_path:
                    agent.plan_thinking_motion(notify=False)
                nxt = agent.pop_next_walk_step()
                if nxt:
                    step_batch.append((agent.index, float(nxt[0]), float(nxt[1])))

            if not step_batch:
                break

            sent_any = True
            await send_move_command_async(self.ip, self.port, step_batch, delay=0)
            if self._stop_event.is_set():
                await asyncio.sleep(self.idle_delay)
            else:
                await asyncio.sleep(self.step_delay)

        if force:
            final_batch = []
            for agent in agents:
                pos = agent.position if isinstance(agent.position, tuple) else None
                if pos:
                    final_batch.append((agent.index, float(pos[0]), float(pos[1])))
            if final_batch and not sent_any:
                await send_move_command_async(self.ip, self.port, final_batch, delay=0)

def send_speak_command(ip: str, port: int, object_id: int, message: str):
    try:
        client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        client.connect((ip, port))
        command = f"SPEAK:{object_id}:{message}"
        client.sendall(command.encode("utf-8"))
        client.close()
    except Exception as e:
        logger.error("send_speak_command error: %s", e)

def send_update_ui_command(ip: str, port: int, element_id: int, new_text: str):
    global UI_SOCKET_AVAILABLE
    if not UI_SOCKET_AVAILABLE:
        return
    try:
        with socket.create_connection((ip, port), timeout=0.5) as client:
            command = f"UPDATE_UI:{element_id}:{new_text}"
            client.sendall(command.encode("utf-8"))
    except (ConnectionRefusedError, socket.timeout, TimeoutError) as e:
        if UI_SOCKET_AVAILABLE:
            UI_SOCKET_AVAILABLE = False
            logger.warning("UI socket unavailable, stop sending UPDATE_UI commands: %s", e)
    except Exception as e:
        logger.error("send_update_ui_command error: %s", e)

def broadcast_walk_paths(ip: str, port: int, agents: List["Agent"], step_delay: float = 0.55, idle_delay: float = 0.15):
    """ÊâπÊ¨°ÈÄÅÂá∫Â§ö Agent ÁöÑÈÄêÊ≠•Ë∑ØÂæëÔºàËã•ÊúâÔºâÔºåÂê¶ÂâáÈÄÅÁï∂ÂâçÂÆöÈªû‰ΩçÁΩÆ„ÄÇ"""
    if not agents:
        return
    active = any(a.has_pending_walk() for a in agents)
    if not active:
        batch = [(a.index, float(a.position[0]), float(a.position[1])) for a in agents if isinstance(a.position, tuple)]
        if batch:
            send_move_command(ip, port, batch, delay=idle_delay)
        return

    while any(a.has_pending_walk() for a in agents):
        step_batch = []
        for a in agents:
            nxt = a.pop_next_walk_step()
            cur = nxt if isinstance(nxt, tuple) else (a.position if isinstance(a.position, tuple) else None)
            if cur:
                step_batch.append((a.index, float(cur[0]), float(cur[1])))
        if step_batch:
            send_move_command(ip, port, step_batch, delay=step_delay)

    final_batch = [(a.index, float(a.position[0]), float(a.position[1])) for a in agents if isinstance(a.position, tuple)]
    if final_batch:
        send_move_command(ip, port, final_batch, delay=idle_delay)

# ---------------------------
# Utility
# ---------------------------
def add_random_noise(location: str, map_dict: Dict[str, Any]) -> Tuple[float, float]:
    anchor = map_dict.get(location)
    if anchor is None:
        raise KeyError(f"Location '{location}' not found.")
    if isinstance(anchor, dict):
        anchor = anchor.get("anchor") or anchor.get("anchors")
    base = random.choice(anchor) if isinstance(anchor, list) else anchor
    x, y = float(base[0]), float(base[1])
    return (x + random.uniform(-3, 3), y + random.uniform(-3, 3))

def generate_walk_path(start: Tuple[float, float], end: Tuple[float, float], step_size: float = 2.8, jitter: float = 0.4):
    dx, dy = end[0] - start[0], end[1] - start[1]
    dist = math.hypot(dx, dy)
    if dist < 1e-3:
        return []
    segs = max(1, int(math.ceil(dist / max(step_size, 1e-3))))
    path: List[Tuple[float, float]] = []
    for i in range(1, segs + 1):
        t = i / segs
        if i == segs:
            path.append(end)
        else:
            path.append((start[0] + dx * t + random.uniform(-jitter, jitter),
                         start[1] + dy * t + random.uniform(-jitter, jitter)))
    return path

def DBSCAN_chat(agents: List["Agent"]) -> Optional[List["Agent"]]:
    points = [a.position for a in agents]
    arr = np.array(points)
    db = DBSCAN(eps=4.5, min_samples=1)
    labels = db.fit_predict(arr)
    clusters: List[List[Agent]] = []
    for label, agent in zip(labels, agents):
        while label >= len(clusters):
            clusters.append([])
        clusters[label].append(agent)
    candidates = [c for c in clusters if len(c) >= 2]
    if not candidates:
        return None
    if random.random() < 0.8:
        return random.choice(candidates)
    return None

def get_now_time(oldtime: str, step_num: int, min_per_step: int) -> str:
    dt = datetime.strptime(oldtime, "%Y-%m-%d-%H-%M")
    return (dt + timedelta(minutes=min_per_step * step_num)).strftime("%Y-%m-%d-%H-%M")

def get_weekday(nowtime: str) -> str:
    dt = datetime.strptime(nowtime, "%Y-%m-%d-%H-%M")
    return ["ÊòüÊúü‰∏Ä", "ÊòüÊúü‰∫å", "ÊòüÊúü‰∏â", "ÊòüÊúüÂõõ", "ÊòüÊúü‰∫î", "ÊòüÊúüÂÖ≠", "ÊòüÊúüÂ§©"][dt.weekday()]

def format_date_time(date_str: str) -> str:
    dt = datetime.strptime(date_str, "%Y-%m-%d-%H-%M")
    return dt.strftime("%YÂπ¥%mÊúà%dÊó•%HÁÇπ%MÂàÜ")

def compare_times(time_str1: str, time_str2: str, fmt: str = "%H-%M") -> bool:
    t1 = datetime.strptime(time_str1, fmt)
    t2 = datetime.strptime(time_str2, fmt)
    return t1 < t2

def update_schedule(wake_up_time_str: str, schedule: List[List[Any]]) -> List[List[Any]]:
    wake = datetime.strptime(wake_up_time_str, "%H-%M")
    cur = wake
    out: List[List[Any]] = []
    for activity, duration in schedule:
        out.append([activity, cur.strftime("%H-%M")])
        cur += timedelta(minutes=int(duration))
    return out

def find_current_activity(current_time_str: str, schedule: List[List[str]]) -> List[str]:
    cur = datetime.strptime(current_time_str, "%H-%M")
    for activity, time_str in schedule:
        t = datetime.strptime(time_str.replace(":", "-"), "%H-%M")
        if cur <= t:
            return [activity, time_str]
    return ["Áù°Ë¶∫", current_time_str]

def weekday2START_TIME(weekday: str) -> str:
    base = {
        "ÊòüÊúü‰∏Ä": "2024-11-18-03-00",
        "ÊòüÊúü‰∫å": "2024-11-19-03-00",
        "ÊòüÊúü‰∏â": "2024-11-20-03-00",
        "ÊòüÊúüÂõõ": "2024-11-21-03-00",
        "ÊòüÊúü‰∫î": "2024-11-22-03-00",
        "ÊòüÊúüÂÖ≠": "2024-11-23-03-00",
        "ÊòüÊúüÂ§©": "2024-11-24-03-00",
    }
    return base.get(weekday, "2024-11-18-03-00")

# ---------------------------
# Safe LLM loader (avoids OllamaAgent __init__ arg mismatch crash)
# ---------------------------
class LLMShim:
    """Lazy import async API from run_gpt_prompt; fallback to simple rules if import fails."""
    def __init__(self):
        self.ready = False
        self._load()

    def _load(self):
        try:
            # Áõ°ÈáèÂÑ™ÂÖàËºâÂÖ• tools.* ÁâàÊú¨ÔºàÈÄöÂ∏∏ËºÉÂ∞ëÂâØ‰ΩúÁî®Ôºâ
            from tools.LLM.run_gpt_prompt import (  # type: ignore
                go_map_async,
                modify_schedule_async,
                summarize_async,
                run_gpt_prompt_generate_hourly_schedule,
                run_gpt_prompt_wake_up_hour,
                run_gpt_prompt_pronunciatio,
                double_agents_chat,
                close_llm_session,
            )
            self.go_map_async = go_map_async
            self.modify_schedule_async = modify_schedule_async
            self.summarize_async = summarize_async
            self.generate_hourly = run_gpt_prompt_generate_hourly_schedule
            self.wake_up_hour = run_gpt_prompt_wake_up_hour
            self.pronunciatio = run_gpt_prompt_pronunciatio
            self.double_chat = double_agents_chat
            self.close_session = close_llm_session
            self.ready = True
            logger.info("LLM connected via tools.LLM.run_gpt_prompt")
        except Exception as e_tools:
            try:
                from ai_china_town.tools.LLM.run_gpt_prompt import (  # type: ignore
                    go_map_async,
                    modify_schedule_async,
                    summarize_async,
                    run_gpt_prompt_generate_hourly_schedule,
                    run_gpt_prompt_wake_up_hour,
                    run_gpt_prompt_pronunciatio,
                    double_agents_chat,
                    close_llm_session,
                )
                self.go_map_async = go_map_async
                self.modify_schedule_async = modify_schedule_async
                self.summarize_async = summarize_async
                self.generate_hourly = run_gpt_prompt_generate_hourly_schedule
                self.wake_up_hour = run_gpt_prompt_wake_up_hour
                self.pronunciatio = run_gpt_prompt_pronunciatio
                self.double_chat = double_agents_chat
                self.close_session = close_llm_session
                self.ready = True
                logger.info("LLM connected via ai_china_town.tools.LLM.run_gpt_prompt")
            except Exception as e_pkg:
                # FallbackÔºö‰∏çËÆìÁ®ãÂºèÂ¥©ÊΩ∞ÔºõÁî®Ê•µÁ∞°Ë¶èÂâáÊõø‰ª£
                self.ready = False
                self._install_fallback()
                logger.warning(
                    "LLM import failed; using fallback (no external LLM). "
                    "errors: tools=%s | ai_china_town=%s",
                    repr(e_tools), repr(e_pkg)
                )

    # ---------------- Fallbacks (non-LLM) ----------------
    async def go_map_async(self, name: str, home: str, curr: str, places: List[str], activity: str) -> str:
        # Á∞°ÂñÆÊò†Â∞ÑÔºöÊ¥ªÂãï->Âú∞Èªû
        table = {
            "‰∏äÂ≠∏": "School",
            "Â≠∏Áøí": "School",
            "Áî®È§ê": "Rest",
            "ÂêÉÈ£Ø": "Rest",
            "ÈÅãÂãï": "Gym",
            "Ë≥ºÁâ©": "Super",
            "Êê≠Ëªä": "Subway",
            "Êï£Ê≠•": "Exterior",
            "Áù°Ë¶∫": home,
            "Áù°Ë¶∫": home,
        }
        return table.get(activity, curr or home or "Exterior")

    async def modify_schedule_async(self, schedule_time: List[List[str]], day_tag: str, memory: str,
                                    wake: str, persona: str) -> List[List[str]]:
        # ÂéüÊ®£ËøîÂõû
        return schedule_time

    async def summarize_async(self, content: str, day_tag: str, who: str) -> str:
        # ÂèñÊúÄËøë 200 Â≠ó
        return content[-200:]

    async def generate_hourly(self, persona: str, day_tag: str, today_goal: str = "") -> List[List[Any]]:
        # Ê•µÁ∞°ÔºöËµ∑Â∫ä‚Üí‰∏äÂ≠∏/Â∑•‰Ωú‚ÜíÁî®È§ê‚ÜíÈÅãÂãï‚ÜíË≥ºÁâ©‚ÜíÊï£Ê≠•‚ÜíÂõûÂÆ∂
        return [
            ["Wake", 0],
            ["‰∏äÂ≠∏", 180],
            ["Áî®È§ê", 60],
            ["Â≠∏Áøí", 120],
            ["ÈÅãÂãï", 60],
            ["Ë≥ºÁâ©", 30],
            ["Êï£Ê≠•", 45],
            ["‰ºëÊÅØ", 180],
        ]

    async def wake_up_hour(self, persona: str, day_tag: str, schedule_after_wake: List[List[Any]]) -> str:
        return "07-00"

    async def pronunciatio(self, action: str) -> str:
        return "üòÉ"

    async def double_chat(self, context: Dict[str, Any]) -> Tuple[str, List[List[str]]]:
        a = context["agent1"]["name"]
        b = context["agent2"]["name"]
        return (
            "smalltalk",
            [
                [a, "Êó©ÂÆâÔºÅ‰ªäÂ§©ÊâìÁÆóÂÅö‰ªÄÈ∫ºÔºü"],
                [b, "ÊàëÊ∫ñÂÇôÂéªË∂ÖÂ∏ÇË≤∑ÈªûÊù±Ë•øÔºåÈ†Ü‰æøÊï£Ê≠•„ÄÇ"],
                [a, "Â•ΩÂïäÔºåË∑Ø‰∏äÂ∞èÂøÉ„ÄÇ"],
            ],
        )

    async def close_session(self):
        return

    def _install_fallback(self):
        # methods already defined above in class namespace
        pass

LLM = LLMShim()

# ---------------------------
# Agent
# ---------------------------
class Agent:
    def __init__(self, name: str, index: int, coord_map: Dict[str, Any]):
        self.name = name
        self.index = index  # Unity Á´Ø‰ª•Â∫èËôüË≠òÂà•
        self.MAP = coord_map

        self.home: str = DEFAULT_AGENT_HOMES.get(name, "Apartment_F1")
        self.curr_place: str = ""
        self.position: Tuple[float, float] = (0.0, 0.0)

        self.walk_path: List[Tuple[float, float]] = []
        self.last_destination: Optional[Tuple[float, float]] = None
        self.is_thinking: bool = False
        self.schedule: List[List[Any]] = []
        self.wake: str = "07-00"
        self.schedule_time: List[List[str]] = []
        self.last_action: str = ""
        self.curr_action: str = ""
        self.curr_action_pronunciatio: str = ""
        self.memory: str = ""
        self.talk_arr: List[List[str]] = []

        # ËºâÂÖ•ÂÄã‰∫∫Ë®≠ÂÆöÔºàÂèØÈÅ∏Ôºâ
        profile_path = os.path.join("agents", self.name, "1.txt")
        self.persona_summary = self._read_persona(profile_path)

    def _read_persona(self, path: str) -> str:
        if not os.path.exists(path):
            return f"{self.name} ÊòØÊ®°Êì¨‰ª£ÁêÜ‰∫∫„ÄÇ"
        try:
            with open(path, "r", encoding="utf-8") as f:
                lines = f.readlines()
            # Á∞°ÂñÆÂèñÁ¨¨ 7 Ë°åÔºàËàáËàäÁâàÁõ∏ÂÆπÔºâÔºåÊàñÂêà‰ΩµÂâçÂπæË°å
            return (lines[6].strip() if len(lines) >= 7 else "".join(lines[:3])).strip()
        except Exception:
            return f"{self.name} ÊòØÊ®°Êì¨‰ª£ÁêÜ‰∫∫„ÄÇ"

    def _notify_movement(self):
        global MOVEMENT_MANAGER
        if MOVEMENT_MANAGER:
            MOVEMENT_MANAGER.request_push()

    def _resolve_anchor_point(self, location: Optional[str]) -> Optional[Tuple[float, float]]:
        if not location:
            return None
        anchor = self.MAP.get(location)
        if isinstance(anchor, dict):
            anchor = anchor.get("anchor") or anchor.get("anchors")
        if isinstance(anchor, list) and anchor:
            anchor = random.choice(anchor)
        if isinstance(anchor, (list, tuple)) and len(anchor) >= 2:
            return float(anchor[0]), float(anchor[1])
        return None

    # --- movement ---
    def goto_scene(self, scene_name: str, walk: bool = False):
        scene_name = PORTAL_NAME_ALIASES.get(scene_name, scene_name)
        dest = add_random_noise(scene_name, self.MAP)
        self.curr_place = scene_name
        self.last_destination = dest
        if walk and isinstance(self.position, tuple):
            path = generate_walk_path(self.position, dest)
            if path:
                self.walk_path = path
                self._notify_movement()
                return
        self.walk_path = []
        self.position = dest
        self._notify_movement()

    def has_pending_walk(self) -> bool:
        return bool(self.walk_path)

    def pop_next_walk_step(self) -> Optional[Tuple[float, float]]:
        if not self.walk_path:
            return None
        nxt = self.walk_path.pop(0)
        self.position = nxt
        return nxt

    def plan_idle_wander(self, radius: float = 3.5, notify: bool = True) -> bool:
        if self.walk_path:
            return False
        anchor = self.MAP.get(self.curr_place)
        if isinstance(anchor, dict):
            anchor = anchor.get("anchor")
        anchor = anchor or self.position
        target = (anchor[0] + random.uniform(-radius, radius), anchor[1] + random.uniform(-radius, radius))
        if math.hypot(target[0] - self.position[0], target[1] - self.position[1]) < 0.5:
            target = (anchor[0] + random.choice([-radius, radius]) * 0.5, anchor[1] + random.choice([-radius, radius]) * 0.5)
        go = generate_walk_path(self.position, target, step_size=1.6, jitter=0.25)
        back_anchor = add_random_noise(self.curr_place, self.MAP)
        back = generate_walk_path(go[-1] if go else self.position, back_anchor, step_size=1.6, jitter=0.25)
        seq = [p for p in go + back if isinstance(p, tuple)]
        if seq:
            self.walk_path.extend(seq)
            if notify:
                self._notify_movement()
            return True
        return False

    def plan_micro_adjustment(self, radius: float = 1.4, notify: bool = True) -> bool:
        if self.walk_path or not isinstance(self.position, tuple):
            return False
        target = (
            self.position[0] + random.uniform(-radius, radius),
            self.position[1] + random.uniform(-radius, radius),
        )
        path = generate_walk_path(self.position, target, step_size=1.0, jitter=0.2)
        if path:
            self.walk_path.extend(path)
            if notify:
                self._notify_movement()
            return True
        return False

    def _plan_slow_move_to_anchor(self, notify: bool = True) -> bool:
        if self.walk_path or not isinstance(self.position, tuple):
            return False
        anchor = self.last_destination or self._resolve_anchor_point(self.curr_place) or self._resolve_anchor_point(self.home)
        if not anchor:
            return False
        if math.hypot(anchor[0] - self.position[0], anchor[1] - self.position[1]) < 0.6:
            return False
        path = generate_walk_path(self.position, anchor, step_size=1.2, jitter=0.2)
        if path:
            self.walk_path.extend(path)
            if notify:
                self._notify_movement()
            return True
        return False

    def plan_thinking_motion(self, notify: bool = True) -> bool:
        if self.walk_path:
            return False
        strategies = [
            lambda: self._plan_slow_move_to_anchor(notify=notify),
            lambda: self.plan_idle_wander(radius=2.5, notify=notify),
            lambda: self.plan_micro_adjustment(radius=1.1, notify=notify),
        ]
        random.shuffle(strategies)
        for strat in strategies:
            if strat():
                return True
        return False

    def begin_thinking(self):
        self.is_thinking = True
        if not self.walk_path:
            self.plan_thinking_motion()

    def finish_thinking(self):
        self.is_thinking = False


# ---------------------------
# High-level sim helpers
# ---------------------------
def _serialize_dialogues(dialogues: List[List[str]]) -> str:
    try:
        return json.dumps(dialogues, ensure_ascii=False)
    except Exception:
        return "\n".join(f"{s}: {u}" for s, u in dialogues if isinstance(s, str) and isinstance(u, str))

def _build_chat_context(a: Agent, b: Agent, now_time: str, weekday_label: str) -> Dict[str, Any]:
    location = a.curr_place or b.curr_place or a.home or b.home
    history = (a.talk_arr or [])[-10:]
    fmt_time = f"{format_date_time(now_time)}({weekday_label})"
    return {
        "location": location,
        "now_time": fmt_time,
        "history": history,
        "agent1": {"name": a.name, "mbti": a.name, "persona": a.persona_summary, "memory": a.memory, "action": a.curr_action or a.last_action},
        "agent2": {"name": b.name, "mbti": b.name, "persona": b.persona_summary, "memory": b.memory, "action": b.curr_action or b.last_action},
    }

async def _update_daily_plan(agent: Agent, now_time: str, weekday_label: str):
    if agent.talk_arr:
        agent.memory = await LLM.summarize_async(_serialize_dialogues(agent.talk_arr), f"{now_time[:10]}-{weekday_label}", agent.name)
        agent.talk_arr.clear()

    agent.goto_scene(agent.home)
    persona = agent.persona_summary
    today_goal = "‰øùÊåÅËâØÂ•ΩÂøÉÊÉÖ"

    schedule = await LLM.generate_hourly(persona, f"{now_time[:10]}-{weekday_label}", today_goal)
    agent.schedule = schedule if isinstance(schedule, list) else []
    schedule_for_wake = agent.schedule[1:] if len(agent.schedule) > 1 else agent.schedule
    agent.wake = await LLM.wake_up_hour(persona, now_time[:10] + weekday_label, schedule_for_wake)

    if ":" in agent.wake:
        agent.wake = agent.wake.replace(":", "-")
    if "-" not in agent.wake:
        s = agent.wake
        if len(s) == 2:
            agent.wake = f"0{s[0]}-0{s[1:]}"
        elif len(s) == 3:
            agent.wake = f"0{s[0]}-{s[1:]}"
        elif len(s) == 4:
            agent.wake = f"{s[:2]}-{s[2:]}"

    agent.schedule_time = update_schedule(agent.wake, [item[:2] for item in schedule_for_wake] or [["‰ºëÊÅØ", 1440]])
    agent.schedule_time = await LLM.modify_schedule_async(agent.schedule_time, f"{now_time[:10]}-{weekday_label}", agent.memory, agent.wake, persona)

    agent.curr_action = "Áù°Ë¶∫"
    agent.last_action = "Áù°Ë¶∫"
    agent.curr_place = agent.home
    agent.curr_action_pronunciatio = "üò¥"
    send_speak_command(UNITY_IP, UNITY_PORT, agent.index, agent.curr_action)
    logger.info("%s ÂΩìÂâçÊ¥ªÂä®: %s(%s)---ÊâÄÂú®Âú∞ÁÇπ(%s)", agent.name, agent.curr_action, agent.curr_action_pronunciatio, agent.curr_place)

async def _process_agent_activity(agent: Agent, now_time: str, weekday_label: str):
    current_hm = now_time[-5:]
    if compare_times(current_hm, agent.wake):
        agent.curr_action = "Áù°Ë¶∫"
        if agent.curr_place != agent.home:
            agent.goto_scene(agent.home, walk=True)
        else:
            agent.curr_place = agent.home
        agent.curr_action_pronunciatio = "üò¥"
        logger.debug("%s Áù°Ë¶∫ @ %s", agent.name, agent.curr_place)
        return

    if isinstance(agent.schedule_time, list) and agent.schedule_time:
        current_activity = find_current_activity(current_hm, agent.schedule_time)[0]
    else:
        current_activity = "‰ºëÊÅØ"

    categorized, emoji = classify_activity(current_activity)
    agent.curr_action_pronunciatio = emoji

    if agent.last_action != categorized:
        agent.begin_thinking()
        try:
            next_place = await LLM.go_map_async(agent.name, agent.home, agent.curr_place, CAN_GO_PLACES, current_activity)
        finally:
            agent.finish_thinking()
        agent.curr_place = PORTAL_NAME_ALIASES.get(next_place, next_place)
        agent.goto_scene(agent.curr_place, walk=True)
        send_speak_command(UNITY_IP, UNITY_PORT, agent.index, categorized)
        agent.last_action = categorized

    agent.curr_action = categorized
    logger.info("%s ÂΩìÂâçÊ¥ªÂä®: %s(%s)---ÊâÄÂú®Âú∞ÁÇπ(%s)", agent.name, agent.curr_action, agent.curr_action_pronunciatio, agent.curr_place)

async def _handle_possible_chat(agents: List[Agent], now_time: str, weekday_label: str):
    pair = DBSCAN_chat(agents)
    if not pair:
        return
    a, b = pair[0], pair[1]
    if a.curr_place != b.curr_place:
        return
    a.curr_action = b.curr_action = "ËÅäÂ§©"
    a.curr_action_pronunciatio = ACTION_EMOJI["ËÅäÂ§©"]
    b.curr_action_pronunciatio = ACTION_EMOJI["ËÅäÂ§©"]
    a.last_action = b.last_action = "ËÅäÂ§©"
    ctx = _build_chat_context(a, b, now_time, weekday_label)
    thought, dialogue = await LLM.double_chat(ctx)
    if not isinstance(dialogue, list):
        logger.warning("LLM ËÅäÂ§©Ëº∏Âá∫Ê†ºÂºèÁï∞Â∏∏: %s", dialogue)
        return
    combined: List[List[str]] = []
    a_lines, b_lines = [], []
    for idx, item in enumerate(dialogue, start=1):
        if not (isinstance(item, (list, tuple)) and len(item) >= 2):
            continue
        speaker, utterance = item[0], item[1]
        combined.append([speaker, utterance])
        if speaker == a.name:
            a_lines.append(f"{idx}. {utterance}")
        elif speaker == b.name:
            b_lines.append(f"{idx}. {utterance}")
    if combined:
        a.talk_arr.extend(combined)
        b.talk_arr.extend(combined)
        send_speak_command(UNITY_IP, UNITY_PORT, a.index, "\n".join(a_lines))
        send_speak_command(UNITY_IP, UNITY_PORT, b.index, "\n".join(b_lines))
        logger.info("ËÅäÂ§©ÂÖßÂÆπ(%s): %s", thought, combined)

# ---------------------------
# Main simulation
# ---------------------------
async def run_simulation(steps: int, min_per_step: int, weekday: str):
    # Âª∫Á´ã AgentsÔºàÂ∫èËôü = Unity Áâ©‰ª∂ IDÔºâ
    agents: List[Agent] = []
    for idx, name in enumerate(DEFAULT_AGENT_ORDER):
        ag = Agent(name=name, index=idx, coord_map=COORDINATE_MAP)
        ag.goto_scene(ag.home)  # ÂàùÂßãËêΩÈªû
        agents.append(ag)

    now_time = weekday2START_TIME(weekday)
    send_update_ui_command(UNITY_IP, UNITY_PORT, 0, f"ÂΩìÂâçÊó∂Èó¥Ôºö{now_time}")
    movement_manager = MovementController(UNITY_IP, UNITY_PORT, agents)
    global MOVEMENT_MANAGER
    MOVEMENT_MANAGER = movement_manager
    movement_task = asyncio.create_task(movement_manager.run())
    movement_manager.request_push()
    # ÊØèÂ§©ÈáçÁΩÆÁöÑÊ≠•Êï∏ÈñìÈöî
    day_step_interval = max(1, int(1440 / max(min_per_step, 1)))
    try:
        for step in range(steps):
            weekday_label = get_weekday(now_time)
            formatted_time = format_date_time(now_time)
            send_update_ui_command(UNITY_IP, UNITY_PORT, 0, f"ÂΩìÂâçÊó∂Èó¥Ôºö{formatted_time}({weekday_label})")

            if step % day_step_interval == 0:
                logger.info("Êñ∞ÁöÑ‰∏ÄÂ§©Ôºö%s(%s)", formatted_time, weekday_label)
                for a in agents:
                    await _update_daily_plan(a, now_time, weekday_label)
            else:
                for a in agents:
                    await _process_agent_activity(a, now_time, weekday_label)
                # ÂòóË©¶Ëß∏ÁôºËÅäÂ§©
                await _handle_possible_chat(agents, now_time, weekday_label)

            now_time = get_now_time(now_time, 1, min_per_step)

        logger.info("Ê®°Êì¨ÁµêÊùü„ÄÇ")
    finally:
        try:
            await movement_manager.stop()
        finally:
            await movement_task
            if MOVEMENT_MANAGER is movement_manager:
                MOVEMENT_MANAGER = None
        try:
            await LLM.close_session()
        except Exception:
            pass

# ---------------------------
# CLI
# ---------------------------
def parse_arguments():
    p = argparse.ArgumentParser(description="Unity ÂâçÁ´ØÂ∞èÈéÆÊ®°Êì¨ÔºàÊ∏ÖÁêÜÁâàÔºâ")
    p.add_argument("--steps", type=int, default=60, help="Ê®°Êì¨Ê≠•Êï∏")
    p.add_argument("--minutes-per-step", type=int, default=30, help="ÊØèÊ≠•Ê®°Êì¨ÂàÜÈêòÊï∏")
    p.add_argument("--weekday", default="ÊòüÊúü‰∏Ä", help="Ëµ∑ÂßãÊòüÊúüÔºöÊòüÊúü‰∏Ä~ÊòüÊúüÂ§©")
    return p.parse_args()

def main():
    args = parse_arguments()
    asyncio.run(run_simulation(args.steps, args.minutes_per_step, args.weekday))

if __name__ == "__main__":
    main()
