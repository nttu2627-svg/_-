# simulation_logic/agent_classes.py (ÂÆåÊï¥ÊúÄÁµÇÁâà)

import random
import os
import json
from datetime import datetime, timedelta
import sys
# ‰ªéÊàë‰ª¨ÈáçÊûÑÂêéÁöÑÊ®°ÁªÑ‰∏≠ÂØºÂÖ•
from tools.LLM import run_gpt_prompt as llm
from .agent_memory import update_agent_schedule
from .schedule_manager import ÂæûÊ™îÊ°àËºâÂÖ•Ë°åÁ®ãË°®
# --- ËºïÈáèÂåñÊôÇ‰ΩøÁî®ÁöÑÈ†êË®≠ÂõûÊáâ ---
LIGHTWEIGHT_ACTION_RESPONSES = {
    "Áù°Ë¶∫": ("", "üí§"),
    "ÈÜí‰æÜ": ("Êñ∞ÁöÑ‰∏ÄÂ§©ÈñãÂßã‰∫ÜÔºÅ", "üåÖ"),
    "Á≠âÂæÖÂàùÂßãÂåñ": ("Á®çÁ≠âÔºåÊàëÊ≠£Âú®Á¢∫Ë™ç‰ªäÊó•ÁöÑÂÆâÊéí„ÄÇ", "‚òï"),
    "ÊÑèË≠ò‰∏çÊòé": ("", "üí§"),
}
# --- Ê†∏ÂøÉÔºöÂÆöÁæ©Â†¥ÊôØ‰∏≠ÁöÑÂÇ≥ÈÄÅÈñÄÈÄ£Êé•Èóú‰øÇ ---
# Èçµ(Key): ‰ª£ÁêÜ‰∫∫Áï∂ÂâçÊâÄÂú®ÁöÑÂÇ≥ÈÄÅÈªû GameObject ÂêçÁ®±„ÄÇ
# ÂÄº(Value): ‰ª£ÁêÜ‰∫∫Á©øÈÅéË©≤ÂÇ≥ÈÄÅÈªûÂæåÔºåÊáâË©≤Âá∫ÁèæÁöÑÁõÆÊ®ôÂÇ≥ÈÄÅÈªû GameObject ÂêçÁ®±„ÄÇ
PORTAL_CONNECTIONS = {
    # --- ÂÖ¨ÂØìÂá∫ÂÖ•Âè£ (ÈõôÂêë) ---
    "ÂÖ¨ÂØìÂ§ßÈñÄ_ÂÆ§ÂÖß": "ÂÖ¨ÂØìÂ§ßÈñÄ_ÂÆ§Â§ñ",
    "ÂÖ¨ÂØìÂ§ßÈñÄ_ÂÆ§Â§ñ": "ÂÖ¨ÂØìÂ§ßÈñÄ_ÂÆ§ÂÖß",
    "ÂÖ¨ÂØìÂÅ¥ÈñÄ_ÂÆ§ÂÖß": "ÂÖ¨ÂØìÂÅ¥ÈñÄ_ÂÆ§Â§ñ",
    "ÂÖ¨ÂØìÂÅ¥ÈñÄ_ÂÆ§Â§ñ": "ÂÖ¨ÂØìÂÅ¥ÈñÄ_ÂÆ§ÂÖß",
    "ÂÖ¨ÂØìÈ†ÇÊ®ì_ÂÆ§ÂÖß": "ÂÖ¨ÂØìÈ†ÇÊ®ì_ÂÆ§Â§ñ",
    "ÂÖ¨ÂØìÈ†ÇÊ®ì_ÂÆ§Â§ñ": "ÂÖ¨ÂØìÈ†ÇÊ®ì_ÂÆ§ÂÖß",

    # --- ÂÖ¨ÂØìÊ®ìÂ±§Èñì (ÈõôÂêë) ---
    "ÂÖ¨ÂØì‰∏ÄÊ®ì_ÂÆ§ÂÖß": "ÂÖ¨ÂØì‰∫åÊ®ì_ÂÆ§ÂÖß",
    "ÂÖ¨ÂØì‰∫åÊ®ì_ÂÆ§ÂÖß": "ÂÖ¨ÂØì‰∏ÄÊ®ì_ÂÆ§ÂÖß", # ÂÅáË®≠ÂèØ‰ª•Âæû‰∫åÊ®ìËµ∞Âõû‰∏ÄÊ®ì
    "ÂÖ¨ÂØì‰∫åÊ®ì_ÂÆ§ÂÖß_‰∏ä": "ÂÖ¨ÂØìÈ†ÇÊ®ì_ÂÆ§ÂÖß", # ÂÅáË®≠ÊúâÊòéÁ¢∫ÁöÑ‰∏ä‰∏ãÊ®ìÁâ©‰ª∂
    "ÂÖ¨ÂØìÈ†ÇÊ®ì_ÂÆ§ÂÖß_‰∏ã": "ÂÖ¨ÂØì‰∫åÊ®ì_ÂÆ§ÂÖß",

    # --- Ë∂ÖÂ∏ÇÂá∫ÂÖ•Âè£ (ÈõôÂêë) ---
    "Ë∂ÖÂ∏ÇÂÅ¥ÈñÄ_ÂÆ§ÂÖß": "Ë∂ÖÂ∏ÇÂÅ¥ÈñÄ_ÂÆ§Â§ñ",
    "Ë∂ÖÂ∏ÇÂÅ¥ÈñÄ_ÂÆ§Â§ñ": "Ë∂ÖÂ∏ÇÂÅ¥ÈñÄ_ÂÆ§ÂÖß",
    "Ë∂ÖÂ∏ÇÂ∑¶ÈñÄ_ÂÆ§ÂÖß": "Ë∂ÖÂ∏ÇÂ∑¶ÈñÄ_ÂÆ§Â§ñ",
    "Ë∂ÖÂ∏ÇÂ∑¶ÈñÄ_ÂÆ§Â§ñ": "Ë∂ÖÂ∏ÇÂ∑¶ÈñÄ_ÂÆ§ÂÖß",
    "Ë∂ÖÂ∏ÇÂè≥ÈñÄ_ÂÆ§ÂÖß": "Ë∂ÖÂ∏ÇÂè≥ÈñÄ_ÂÆ§Â§ñ",
    "Ë∂ÖÂ∏ÇÂè≥ÈñÄ_ÂÆ§Â§ñ": "Ë∂ÖÂ∏ÇÂè≥ÈñÄ_ÂÆ§ÂÖß",
    
    # --- Âú∞ÈêµÂá∫ÂÖ•Âè£ (Ë§áÈõúÈóú‰øÇÔºåÈõôÂêë) ---
    # ÂæûÂÆ§ÂÖßÂá∫Âéª (‰∏ÄÂ∞çÂ§öÔºåÈö®Ê©üÈÅ∏‰∏ÄÂÄãÂá∫Âè£)
    "Âú∞ÈêµÂ∑¶Ê®ìÊ¢Ø_ÂÆ§ÂÖß": ["Âú∞ÈêµÂ∑¶ÂÖ•Âè£_ÂÆ§Â§ñ", "Âú∞Èêµ‰∏äÂÖ•Âè£_ÂÆ§Â§ñ"],
    "Âú∞ÈêµÂè≥Ê®ìÊ¢Ø_ÂÆ§ÂÖß": ["Âú∞ÈêµÂè≥ÂÖ•Âè£_ÂÆ§Â§ñ", "Âú∞Èêµ‰∏ãÂÖ•Âè£_ÂÆ§Â§ñ"],
    # ÂæûÂÆ§Â§ñÈÄ≤‰æÜ (Â§öÂ∞ç‰∏Ä)
    "Âú∞ÈêµÂ∑¶ÂÖ•Âè£_ÂÆ§Â§ñ": "Âú∞ÈêµÂ∑¶Ê®ìÊ¢Ø_ÂÆ§ÂÖß",
    "Âú∞Èêµ‰∏äÂÖ•Âè£_ÂÆ§Â§ñ": "Âú∞ÈêµÂ∑¶Ê®ìÊ¢Ø_ÂÆ§ÂÖß",
    "Âú∞ÈêµÂè≥ÂÖ•Âè£_ÂÆ§Â§ñ": "Âú∞ÈêµÂè≥Ê®ìÊ¢Ø_ÂÆ§ÂÖß",
    "Âú∞Èêµ‰∏ãÂÖ•Âè£_ÂÆ§Â§ñ": "Âú∞ÈêµÂè≥Ê®ìÊ¢Ø_ÂÆ§ÂÖß",

    # --- ÂÖ∂‰ªñÂñÆ‰∏ÄÂá∫ÂÖ•Âè£Âª∫ÁØâ (ÈõôÂêë) ---
    "Â≠∏Ê†°ÈñÄÂè£_ÂÆ§ÂÖß": "Â≠∏Ê†°ÈñÄÂè£_ÂÆ§Â§ñ",
    "Â≠∏Ê†°ÈñÄÂè£_ÂÆ§Â§ñ": "Â≠∏Ê†°ÈñÄÂè£_ÂÆ§ÂÖß",
    "ÂÅ•Ë∫´Êàø_ÂÆ§ÂÖß": "ÂÅ•Ë∫´Êàø_ÂÆ§Â§ñ",
    "ÂÅ•Ë∫´Êàø_ÂÆ§Â§ñ": "ÂÅ•Ë∫´Êàø_ÂÆ§ÂÖß",
    "È§êÂª≥_ÂÆ§ÂÖß": "È§êÂª≥_ÂÆ§Â§ñ",
    "È§êÂª≥_ÂÆ§Â§ñ": "È§êÂª≥_ÂÆ§ÂÖß",
}
LOCATION_ENTRY_PORTALS = {
    "Apartment": "ÂÖ¨ÂØìÂ§ßÈñÄ_ÂÆ§Â§ñ",
    "Apartment_F1": "ÂÖ¨ÂØìÂ§ßÈñÄ_ÂÆ§Â§ñ",
    "Apartment_F2": "ÂÖ¨ÂØìÂ§ßÈñÄ_ÂÆ§Â§ñ",
    "School": "Â≠∏Ê†°ÈñÄÂè£_ÂÆ§Â§ñ",
    "Rest": "È§êÂª≥_ÂÆ§Â§ñ",
    "Gym": "ÂÅ•Ë∫´Êàø_ÂÆ§Â§ñ",
    "Super": "Ë∂ÖÂ∏ÇÂè≥ÈñÄ_ÂÆ§Â§ñ",
    "Subway": "Âú∞ÈêµÂ∑¶ÂÖ•Âè£_ÂÆ§Â§ñ",
}
SUBWAY_INTERIOR_PORTALS = {
    "Âú∞ÈêµÂ∑¶Ê®ìÊ¢Ø_ÂÆ§ÂÖß",
    "Âú∞ÈêµÂè≥Ê®ìÊ¢Ø_ÂÆ§ÂÖß"
}
PORTAL_DESTINATION_ALIASES = {
    "ÂÖ¨ÂØìÂ§ßÈñÄ_ÂÆ§ÂÖß": "Apartment_F1",
    "ÂÖ¨ÂØìÂÅ¥ÈñÄ_ÂÆ§ÂÖß": "Apartment_F1",
    "ÂÖ¨ÂØì‰∏ÄÊ®ì_ÂÆ§ÂÖß": "Apartment_F1",
    "ÂÖ¨ÂØì‰∫åÊ®ì_ÂÆ§ÂÖß": "Apartment_F2",
    "ÂÖ¨ÂØìÈ†ÇÊ®ì_ÂÆ§ÂÖß": "Apartment_F2",
    "ÂÖ¨ÂØìÂ§ßÈñÄ_ÂÆ§Â§ñ": "Exterior",
    "ÂÖ¨ÂØìÂÅ¥ÈñÄ_ÂÆ§Â§ñ": "Exterior",
    "ÂÖ¨ÂØìÈ†ÇÊ®ì_ÂÆ§Â§ñ": "Exterior",
    "ÂÅ•Ë∫´Êàø_ÂÆ§ÂÖß": "Gym",
    "ÂÅ•Ë∫´Êàø_ÂÆ§Â§ñ": "Exterior",
    "Â≠∏Ê†°ÈñÄÂè£_ÂÆ§ÂÖß": "School",
    "Â≠∏Ê†°ÈñÄÂè£_ÂÆ§Â§ñ": "Exterior",
    "È§êÂª≥_ÂÆ§ÂÖß": "Rest",
    "È§êÂª≥_ÂÆ§Â§ñ": "Exterior",
    "Ë∂ÖÂ∏ÇÂÅ¥ÈñÄ_ÂÆ§ÂÖß": "Super",
    "Ë∂ÖÂ∏ÇÂ∑¶ÈñÄ_ÂÆ§ÂÖß": "Super",
    "Ë∂ÖÂ∏ÇÂè≥ÈñÄ_ÂÆ§ÂÖß": "Super",
    "Ë∂ÖÂ∏ÇÂÅ¥ÈñÄ_ÂÆ§Â§ñ": "Exterior",
    "Ë∂ÖÂ∏ÇÂ∑¶ÈñÄ_ÂÆ§Â§ñ": "Exterior",
    "Ë∂ÖÂ∏ÇÂè≥ÈñÄ_ÂÆ§Â§ñ": "Exterior",
    "Âú∞ÈêµÂ∑¶Ê®ìÊ¢Ø_ÂÆ§ÂÖß": "Subway",
    "Âú∞ÈêµÂè≥Ê®ìÊ¢Ø_ÂÆ§ÂÖß": "Subway",
    "Âú∞ÈêµÂ∑¶ÂÖ•Âè£_ÂÆ§Â§ñ": "Exterior",
    "Âú∞ÈêµÂè≥ÂÖ•Âè£_ÂÆ§Â§ñ": "Exterior",
    "Âú∞Èêµ‰∏äÂÖ•Âè£_ÂÆ§Â§ñ": "Exterior",
    "Âú∞Èêµ‰∏ãÂÖ•Âè£_ÂÆ§Â§ñ": "Exterior",
}

# --- ÂãïÊÖãËºâÂÖ•‰ª£ÁêÜ‰∫∫Ë®≠ÂÆö ---
BASE_DIR = './agents/'

def read_file(file_path):
    try:
        with open(file_path, "r", encoding="utf-8") as file: return file.read()
    except Exception as e: return f"ËÆÄÂèñÊ™îÊ°à {file_path} Âá∫ÈåØ: {e}"

def parse_profile_from_content(content):
    profile = {}
    for line in content.splitlines():
        if ":" in line:
            key, value = line.split(":", 1)
            key_lower = key.strip().lower()
            if 'name' in key_lower: profile['name'] = value.strip()
            elif 'mbti' in key_lower: profile['mbti'] = value.strip()
            elif 'personality' in key_lower: profile['desc'] = value.strip()
    return profile

def load_mbti_profiles_from_files(base_dir):
    profiles = {}
    if not os.path.exists(base_dir): return {}
    mbti_cooperation = {'ISTJ': 0.2, 'ISFJ': 0.5, 'INFJ': 0.6, 'INTJ': 0.3, 'ISTP': 0.4, 'ISFP': 0.5, 'INFP': 0.7, 'INTP': 0.4, 'ESTP': 0.6, 'ESFP': 0.7, 'ENFP': 0.8, 'ENTP': 0.7, 'ESTJ': 0.8, 'ESFJ': 0.9, 'ENFJ': 0.9, 'ENTJ': 0.8}
    for mbti_type in os.listdir(base_dir):
        agent_folder = os.path.join(base_dir, mbti_type)
        if os.path.isdir(agent_folder):
            profile_path = os.path.join(agent_folder, '1.txt')
            if os.path.exists(profile_path):
                content = read_file(profile_path)
                parsed_profile = parse_profile_from_content(content)
                desc = parsed_profile.get('desc', 'ÁÑ°ÊèèËø∞')
                coop = mbti_cooperation.get(mbti_type.upper(), 0.5)
                profiles[mbti_type.upper()] = {'desc': desc, 'cooperation': coop}
    return profiles

MBTI_PROFILES = load_mbti_profiles_from_files(BASE_DIR)

class Building:
    def __init__(self, bld_id, position, integrity=100.0):
        self.id = bld_id
        self.position = position
        self.integrity = float(integrity)

    def apply_damage(self, intensity):
        vulnerability = (100 - self.integrity) / 100.0
        damage = (intensity * 20) + (intensity * 30 * vulnerability) + random.uniform(-5, 5)
        self.integrity = max(0, self.integrity - max(0, damage))
        return damage

class TownAgent:
    def __init__(self, agent_id_mbti, initial_home_name, available_locations):
        self.id = agent_id_mbti.upper()
        self.name = agent_id_mbti.upper()
        self.MBTI = agent_id_mbti.upper()
        self.available_locations = available_locations 
        self.home = initial_home_name
        
        mbti_info = MBTI_PROFILES.get(self.MBTI, {'desc': 'Êú™Áü•ÂÄãÊÄß', 'cooperation': 0.5})
        self.personality_desc = mbti_info['desc']
        self.cooperation_inclination = mbti_info['cooperation']
        self.persona_summary = f"MBTI: {self.MBTI}. ÂÄãÊÄß: {self.personality_desc}"
        
        self.curr_place = initial_home_name
        self.target_place = initial_home_name
        self.previous_place = initial_home_name
        self.last_action = "Á≠âÂæÖÂàùÂßãÂåñ"
        self.curr_action = "Á≠âÂæÖÂàùÂßãÂåñ"
        self.curr_action_pronunciatio = "‚è≥"
        self.current_thought = ""
        self.health = 100
        self.is_injured = False
        self.mental_state = "calm"
        self.current_building = None
        self.interrupted_action = None
        self.memory = "Â∞öÊú™ÁîüÊàê"
        self.weekly_schedule = {}
        self.daily_schedule = []
        self.wake_time = "07-00"
        self.sleep_time = "23-00"
        self.disaster_experience_log = []
        self._pronunciatio_cache = {}
        self.quake_has_taken_cover = False
        self.quake_evacuation_started = False
        self.quake_cooperation_inclination = min(1.0, self.cooperation_inclination + self._compute_quake_bonus())
        self.quake_support_committed = False
        self.is_thinking = False
        self._thinking_depth = 0
        self.sync_events = []

    def is_location_outdoors(self, location_name):
        return "_ÂÆ§Â§ñ" in str(location_name)
    
    def _compute_quake_bonus(self) -> float:
        bonus = 0.25
        if 'F' in self.MBTI:
            bonus += 0.2
        if 'E' in self.MBTI:
            bonus += 0.1
        if 'J' in self.MBTI:
            bonus += 0.05
        if self.MBTI.startswith('IN'):
            bonus += 0.05
        return bonus

    def find_path(self, destination):
        if not destination or destination == self.curr_place:
            return self.curr_place

        destination_str = str(destination)

        if destination_str and destination_str.lower() == "subway":
            if self.curr_place == "Subway" or (self.curr_place and "Âú∞Èêµ" in self.curr_place):
                return "Subway"
            return "Âú∞ÈêµÂ∑¶ÂÖ•Âè£_ÂÆ§Â§ñ"
        
        is_current_outdoors = self.is_location_outdoors(self.curr_place)
        is_destination_outdoors = self.is_location_outdoors(destination_str)

        if is_current_outdoors == is_destination_outdoors:
            return destination_str
        
        elif is_current_outdoors and not is_destination_outdoors:
            entry_portal = LOCATION_ENTRY_PORTALS.get(destination_str)
            if not entry_portal:
                base_key = destination_str.split('_')[0]
                entry_portal = LOCATION_ENTRY_PORTALS.get(base_key, destination_str)
            if entry_portal in PORTAL_CONNECTIONS or entry_portal in self.available_locations:
                return entry_portal
            return destination_str

            
        else:
            if self.curr_place in PORTAL_CONNECTIONS:
                return self.curr_place
            
            building_name = self.curr_place.split('_')[0]
            main_exit = f"{building_name}Â§ßÈñÄ_ÂÆ§ÂÖß"
            if main_exit in PORTAL_CONNECTIONS:
                return main_exit
            for portal in PORTAL_CONNECTIONS.keys():
                if portal.startswith(building_name) and "_ÂÆ§ÂÖß" in portal:
                    return portal
        
        return destination
    def resolve_destination(self, action, destination):
        """Normalize ambiguous destinations to meaningful map locations."""
        previous_target = getattr(self, "target_place", None)
        current_location = self.curr_place or previous_target or self.home or ""

        sleep_keywords = ["Áù°", "sleep", "Sleep"]

        if not destination or destination == action:
            if any(keyword in str(action) for keyword in sleep_keywords):
                return self.home or current_location
            return previous_target or current_location

        destination_str = str(destination)
        if any(keyword in destination_str for keyword in sleep_keywords):
            if destination_str not in self.available_locations:
                return self.home or current_location

        return destination

    def get_schedule_item_at(self, current_time_hm_str):
        try:
            current_t = datetime.strptime(current_time_hm_str, "%H-%M")
        except (ValueError, TypeError):
            return None

        latest_item = None
        for item in self.daily_schedule:
            if len(item) < 2:
                continue
            action, start_str = item[0], item[1]
            target = item[2] if len(item) > 2 else action
            try:
                start_t = datetime.strptime(start_str, "%H-%M")
            except (ValueError, TypeError):
                continue
            if start_t <= current_t:
                latest_item = (action, target)
        return latest_item

    def _enter_thinking(self):
        self._thinking_depth += 1
        self.is_thinking = True

    def _exit_thinking(self):
        if self._thinking_depth > 0:
            self._thinking_depth -= 1
        if self._thinking_depth <= 0:
            self._thinking_depth = 0
            self.is_thinking = False
    async def update_action_by_time(self, current_time_hm_str):
        item = self.get_schedule_item_at(current_time_hm_str)
        if not item:
            return
        action, target = item
        if action != self.curr_action or target != self.target_place:
            await self.set_new_action(action, target)

    def teleport(self, target_portal_name: str):
        destination = PORTAL_CONNECTIONS.get(target_portal_name)

        if not destination:
            print(f"‚ö†Ô∏è [ÂÇ≥ÈÄÅË≠¶Âëä] Âú® PORTAL_CONNECTIONS ‰∏≠Êâæ‰∏çÂà∞ '{target_portal_name}' ÁöÑÂ∞çÊáâÁõÆÊ®ô„ÄÇ")
            self.current_thought = f"ÂóØÔºüÈÄôÊâáÈñÄÂ•ΩÂÉèÊòØÂ£ûÁöÑ... ({target_portal_name})"
            return None


        if isinstance(destination, list):
            chosen = random.choice(destination)
        else:
            chosen = destination

        self.previous_place = self.curr_place

        if chosen in SUBWAY_INTERIOR_PORTALS:
            canonical_place = "Subway"
        else:
            canonical_place = PORTAL_DESTINATION_ALIASES.get(chosen, chosen)

        fallback_candidates = []
        if canonical_place in self.available_locations:
            fallback_candidates.append(canonical_place)
        if chosen in self.available_locations:
            fallback_candidates.append(chosen)
        if self.home in self.available_locations:
            fallback_candidates.append(self.home)
        if "Exterior" in self.available_locations:
            fallback_candidates.append("Exterior")
        if self.available_locations:
            fallback_candidates.append(self.available_locations[0])

        safe_location = next((loc for loc in fallback_candidates if loc), canonical_place)
        self.curr_place = safe_location
        self.target_place = self.curr_place
        self.current_thought = f"Â•Ω‰∫ÜÔºåÊàëÂà∞ '{self.curr_place}' ‰∫Ü„ÄÇ"
        print(f"‚úÖ [ÂÇ≥ÈÄÅÊàêÂäü] {self.name} Âæû '{target_portal_name}' ÂÇ≥ÈÄÅÂà∞ '{self.curr_place}' (Âá∫Âè£: {chosen})")
        event_payload = {
            "type": "teleport",
            "fromPortal": target_portal_name,
            "toPortal": chosen,
            "finalLocation": self.curr_place,
            "targetPlace": self.target_place,
        }
        self.sync_events.append(event_payload)
        return event_payload

    def get_lightweight_response(self, action):
        return LIGHTWEIGHT_ACTION_RESPONSES.get(action)

    async def get_pronunciatio(self, action):
        lightweight = self.get_lightweight_response(action)
        if lightweight:
            return lightweight[1]

        if action in self._pronunciatio_cache:
            return self._pronunciatio_cache[action]

        try:
            result = await llm.run_gpt_prompt_pronunciatio(action)
        except Exception:
            result = ""

        self._pronunciatio_cache[action] = result
        return result

    async def set_new_action(self, new_action, destination):
        resolved_destination = self.resolve_destination(new_action, destination)

        if self.curr_action == new_action and self.target_place == resolved_destination:
            return
        self.interrupt_action()

        self.curr_action = new_action
        self.target_place = resolved_destination
        self.previous_place = self.curr_place
        self.curr_place = self.find_path(resolved_destination)

        lightweight = self.get_lightweight_response(new_action)
        if lightweight:
            thought, pronunciatio = lightweight
            self.current_thought = thought
            self.curr_action_pronunciatio = pronunciatio
            self._thinking_depth = 0
            self.is_thinking = False 
            return

        self._enter_thinking()
        try:
            try:
                self.current_thought = await llm.generate_action_thought(
                    self.persona_summary, self.curr_place, new_action
                )
            except Exception:
                self.current_thought = ""

            self.curr_action_pronunciatio = await self.get_pronunciatio(self.curr_action)
        finally:
            self._exit_thinking()

    def is_asleep(self, current_time_hm_str):
        try:
            wake_t = datetime.strptime(self.wake_time, '%H-%M')
            sleep_t = datetime.strptime(self.sleep_time, '%H-%M')
            current_t = datetime.strptime(current_time_hm_str, '%H-%M')
            if wake_t == sleep_t: return False
            return not (wake_t <= current_t < sleep_t) if wake_t < sleep_t else not (current_t < sleep_t or current_t >= wake_t)
        except (ValueError, TypeError): return False

    def react_to_earthquake(self, intensity, buildings_dict, other_agents_list):
        self.update_current_building(buildings_dict)
        building_integrity = self.current_building.integrity if self.current_building else 100
        damage = 0
        if building_integrity < 50: damage = random.randint(int(intensity * 25), int(intensity * 55))
        elif self.current_building and random.random() < intensity * 0.5: damage = random.randint(1, int(intensity * 30))
        elif not self.current_building and random.random() < intensity * 0.25: damage = random.randint(1, int(intensity * 15))
        self.health = max(0, self.health - damage)
        self.disaster_experience_log.append(f"ÈÅ≠Âèó {damage} ÈªûÂÇ∑ÂÆ≥ (HP: {self.health})")
        if self.health <= 0:
            self.is_injured = True
            self.mental_state = "unconscious"
            self.curr_action = "Unconscious"
            return
        elif self.health < 50: self.is_injured = True
        
        reaction_action_key = "alert"
        new_mental_state = "alert"
        if self.is_injured: 
            reaction_action_key, new_mental_state = "Â∞ãÊâæÈÜ´ÁôÇÊïëÂä©", "injured"
        elif intensity >= 0.65:
            if 'E' in self.MBTI and 'TJ' in self.MBTI: reaction_action_key, new_mental_state = "ÊåáÊèÆÁñèÊï£", "focused"
            elif 'E' in self.MBTI and 'F' in self.MBTI: reaction_action_key, new_mental_state = "ÂÆâÊí´‰ªñ‰∫∫", "panicked"
            elif 'I' in self.MBTI and 'F' in self.MBTI: reaction_action_key, new_mental_state = "Ë∫≤Âà∞Ê°å‰∏ã", "frozen"
            else: reaction_action_key, new_mental_state = "Â∞ãÊâæÂÆâÂÖ®Âá∫Âè£", "alert"
        else:
            if 'J' in self.MBTI: reaction_action_key, new_mental_state = "Ë©ï‰º∞Âë®ÂúçÁí∞Â¢É", "calm"
            else: reaction_action_key, new_mental_state = "Â∞ãÊâæÈÅÆËîΩÁâ©", "alert"
        
        nearby_injured_agents = [
            o
            for o in other_agents_list
            if o.id != self.id and o.health > 0 and o.is_injured and self.Is_nearby(o.get_position())
        ]

        if not self.is_injured and nearby_injured_agents:
            cooperation = self.quake_cooperation_inclination
            help_probability = 0.35
            if cooperation >= 0.9:
                help_probability = 0.97
            elif cooperation >= 0.75:
                help_probability = 0.85
            elif cooperation >= 0.6:
                help_probability = 0.7
            elif cooperation >= 0.45:
                help_probability = 0.55

            self_protection_actions = {"Â∞ãÊâæÈÅÆËîΩÁâ©", "Ë∫≤Âà∞Ê°å‰∏ã", "Â∞ãÊâæÂÆâÂÖ®Âá∫Âè£", "Ë©ï‰º∞Âë®ÂúçÁí∞Â¢É"}
            help_action_key = "ÂçîÂä©ÂèóÂÇ∑ÁöÑ‰∫∫"

            if reaction_action_key in self_protection_actions:
                help_action_key = "Á¢∫Ë™çÂÆâÂÖ®ÂæåÂçîÂä©‰ªñ‰∫∫"
                if (self.current_building and self.current_building.integrity > 40) or not self.current_building or intensity < 0.5:
                    help_probability = min(1.0, help_probability + 0.15)
                else:
                    help_probability *= 0.85

            if random.random() < help_probability:
                reaction_action_key, new_mental_state = help_action_key, "helping"

        
        self.mental_state = new_mental_state
        self.quake_has_taken_cover = False
        self.quake_evacuation_started = False
        self.target_place = self.curr_place
        self.curr_action = "Â∞ãÊâæÈÅÆËîΩÁâ©"
        self.disaster_experience_log.append("Á´ãÂç≥Â∞ãÊâæÊé©Ë≠∑„ÄÇ")

    def perceive_and_help(self, other_agents):
        nearby_candidates = [
            o
            for o in other_agents
            if o.id != self.id and o.health > 0 and (o.is_injured or o.health < 90) and self.Is_nearby(o.get_position())
        ]
        if nearby_candidates:
            target = min(nearby_candidates, key=lambda x: x.health)
            original_hp = target.health
            heal = min(100 - original_hp, max(6, random.randint(8, 20)))
            if heal <= 0:
                heal = 3
            if heal <= 0:
                return None
            target.health = min(100, original_hp + heal)
            target.is_injured = target.health < 60
            message = f"ÂçîÂä© {target.name} (+{heal} HP -> {target.health})"
            return {
                "message": message,
                "ÂèóÂä©ËÄÖ": target.name,
                "ÂéüÂßãHP": original_hp,
                "Ê≤ªÁôÇÈáè": heal,
                "Êñ∞HP": target.health,
            }

        if self.quake_support_committed:
            return None

        potential_allies = [o for o in other_agents if o.id != self.id and o.health > 0]
        if not potential_allies:
            return None

        target = random.choice(potential_allies)
        original_hp = target.health
        heal = min(100 - original_hp, max(2, random.randint(4, 10)))
        if heal <= 0:
            return None
        target.health = min(100, original_hp + heal)
        target.is_injured = target.health < 60
        self.quake_support_committed = True
        message = f"ÂçîÂä© {target.name} Á©©ÂÆöÁãÄÊÖã (+{heal} HP -> {target.health})"
        return {
            "message": message,
            "ÂèóÂä©ËÄÖ": target.name,
            "ÂéüÂßãHP": original_hp,
            "Ê≤ªÁôÇÈáè": heal,
            "Êñ∞HP": target.health,
        }

    def update_current_building(self, buildings_dict):
        self.current_building = buildings_dict.get(self.curr_place)
    
    def get_position(self): return (0, 0)
    def Is_nearby(self, other_agent_position): return True
    def interrupt_action(self):
        if self.curr_action not in ["Áù°Ë¶∫", "Unconscious"]:
            self.interrupted_action = self.curr_action
        else:
            self.interrupted_action = None

    async def initialize_agent(self, current_date, schedule_mode: str, schedule_file_path: str):
        """
        Ê†πÊìöÊåáÂÆöÁöÑÊ®°ÂºèÂàùÂßãÂåñ‰ª£ÁêÜ‰∫∫ÔºåÂæπÂ∫ïÂàÜÈõ¢ preset Âíå llm ÁöÑÈÇèËºØ„ÄÇ
        """
        # --- Preset Ê®°ÂºèÔºöÂÆåÂÖ®‰∏ç‰ΩøÁî® LLM ---
        if schedule_mode == "preset":
            print(f"üèÉ [Agent {self.name}] Ê≠£Âú®‰ª• 'preset' Ê®°ÂºèÂàùÂßãÂåñ...")
            try:
                # Ë®òÊÜ∂ÔºöÁõ¥Êé•‰ΩøÁî® personality_desc ‰ΩúÁÇ∫Âü∫Êú¨Ë®òÊÜ∂
                self.memory = self.persona_summary
                
                # Âæû schedules.json ËÆÄÂèñÈÄ±Ë®àÂäÉÂíåÊó•Ë®àÂäÉ
                with open(schedule_file_path, "r", encoding="utf-8") as f:
                    all_schedules = json.load(f)
                agent_data = all_schedules.get(self.name)
                if not agent_data:
                    print(f"‚ùå [Agent {self.name}] Âú® '{schedule_file_path}' ‰∏≠Êâæ‰∏çÂà∞Â∞çÊáâÁöÑË≥áÊñô„ÄÇ")
                    return False
                
                # ËÆÄÂèñÈÄ±Ë®àÂäÉÔºåÂ¶ÇÊûúÊ≤íÊúâÂ∞±Áµ¶‰∏ÄÂÄãÈ†êË®≠ÂÄº
                self.weekly_schedule = agent_data.get("weeklySchedule", {day: "Ëá™Áî±Ê¥ªÂãï" for day in ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]})
                
                # ÂëºÂè´ update_daily_schedule ËôïÁêÜÊó•Ë®àÂäÉ
                return await self.update_daily_schedule(current_date, "preset", schedule_file_path)

            except Exception as e:
                print(f"‚ùå [Agent {self.name}] Âú® 'preset' Ê®°ÂºèÂàùÂßãÂåñÊúüÈñìÁôºÁîüÈåØË™§: {e}")
                return False

        # --- LLM Ê®°ÂºèÔºöÂÆåÂÖ®Áî± LLM ÁîüÊàê ---
        elif schedule_mode == "llm":
            print(f"ü§ñ [Agent {self.name}] Ê≠£Âú®‰ª• 'llm' Ê®°ÂºèÂàùÂßãÂåñ...")
            self._enter_thinking()
            try:
                # 1. ÁîüÊàêÂàùÂßãË®òÊÜ∂
                memory, mem_success = await llm.run_gpt_prompt_generate_initial_memory(
                    self.name, self.MBTI, self.persona_summary, self.home
                )
                if not mem_success:
                    print(f"‚ùå [Agent {self.name}] LLM ÁîüÊàêÂàùÂßãË®òÊÜ∂Â§±Êïó„ÄÇ")
                    return False
                self.memory = memory

                # 2. ÁîüÊàêÈÄ±Ë®àÂäÉ
                schedule, sched_success = await llm.run_gpt_prompt_generate_weekly_schedule(self.persona_summary)
                if not sched_success:
                    print(f"‚ùå [Agent {self.name}] LLM ÁîüÊàêÈÄ±Ë®àÂäÉÂ§±Êïó„ÄÇ")
                    return False
                self.weekly_schedule = schedule

                # 3. ÁîüÊàêÊó•Ë®àÂäÉ
                return await self.update_daily_schedule(current_date, "llm", schedule_file_path)
            finally:
                self._exit_thinking()
        # Êú™Áü•Ê®°Âºè
        else:
            print(f"‚ùå [Agent {self.name}] Êú™Áü•ÁöÑ schedule_mode: '{schedule_mode}'")
            return False

    async def update_daily_schedule(self, current_date, schedule_mode: str, schedule_file_path: str):
        """Ê†πÊçÆÊ®°ÂºèÊõ¥Êñ∞Âπ∂ËÆæÂÆö‰∏ÄÂ§©ÁöÑÊó•Á®ã„ÄÇ"""
        
        if schedule_mode == "llm":
            print(f"ü§ñ [Agent {self.name}] ‰ΩøÁî® LLM ÁîüÊàê‰ªäÊó•Ë°åÁ®ã...")
            weekday_name = current_date.strftime('%A')
            today_goal = self.weekly_schedule.get(weekday_name, "Ëá™Áî±Ê¥ªÂãï")
            self._enter_thinking()
            try:
                raw_tasks = await llm.run_gpt_prompt_generate_hourly_schedule(
                    self.persona_summary,
                    current_date.strftime('%Y-%m-%d'),
                    today_goal
                )

                if raw_tasks and isinstance(raw_tasks[0], list):
                    wake_time_str = await llm.run_gpt_prompt_wake_up_hour(
                        self.persona_summary,
                        current_date.strftime('%Y-%m-%d'),
                        raw_tasks
                    )
                    if not wake_time_str:
                        return False
                    self.wake_time = wake_time_str.replace(":", "-")

                    self.daily_schedule = update_agent_schedule(self.wake_time, raw_tasks)

                    try:
                        total_duration = sum(int(task[1]) for task in raw_tasks)
                        self.sleep_time = (
                            datetime.strptime(self.wake_time, '%H-%M') + timedelta(minutes=total_duration)
                        ).strftime('%H-%M')
                    except:
                        self.sleep_time = (
                            datetime.strptime(self.wake_time, '%H-%M') + timedelta(hours=16)
                        ).strftime('%H-%M')

                    return True
            finally:
                self._exit_thinking()

        elif schedule_mode == "preset":
            print(f"üíæ [Agent {self.name}] ‰ΩøÁî®È¢ÑËÆæÊ°£Ê°à '{schedule_file_path}' ËΩΩÂÖ•Ë°åÁ®ã...")
            preset_schedule = ÂæûÊ™îÊ°àËºâÂÖ•Ë°åÁ®ãË°®(self.name, schedule_file_path)
            if preset_schedule:
                self.daily_schedule = preset_schedule
                if self.daily_schedule:
                    self.wake_time = self.daily_schedule[0][1]
                    last_activity_time = datetime.strptime(self.daily_schedule[-1][1], '%H-%M')
                    self.sleep_time = (last_activity_time + timedelta(hours=1)).strftime('%H-%M')
                print(f"‚úÖ [Agent {self.name}] Â∑≤ÊàêÂäüÂæûÊ™îÊ°àËºâÂÖ•Ë°åÁ®ã„ÄÇ")
                return True

        print(f"‚ùå [Agent {self.name}] Êó†Ê≥ïÁîüÊàêÊàñËΩΩÂÖ•Ë°åÁ®ã„ÄÇ")
        return False
    async def perform_earthquake_step_action(self, agents, buildings, intensity, disaster_logger, current_time):
        """
        Âú®Âú∞ÈúáÁöÑÊØè‰∏ÄÂÄãÊôÇÈñìÊ≠•È©ü‰∏≠ÔºåÊ±∫ÂÆö‰∏¶Âü∑Ë°å‰ª£ÁêÜ‰∫∫ÁöÑË°åÂãï„ÄÇ
        """
        self.update_current_building(buildings)
        
        # Ê†πÊìöÈö®Ê©üÊÄßÂíåÂª∫ÁØâÊêçÊØÄÂ∫¶ÔºåÊñΩÂä†ÊåÅÁ∫åÂÇ∑ÂÆ≥
        if self.current_building and random.random() < intensity * 0.1 * (120 - self.current_building.integrity) / 100:
            damage = random.randint(1, int(intensity * 10))
            original_hp = self.health
            self.health = max(0, self.health - damage)
            log_msg = f"{self.name} Âõ†Âª∫ÁØâÁâ©ÊêñÊôÉ/ÊéâËêΩÁâ©ÂèóÂà∞ {damage} ÈªûÂÇ∑ÂÆ≥ (HP: {self.health})„ÄÇ"
            self.disaster_experience_log.append(log_msg)
            if disaster_logger:
                disaster_logger.Ë®òÈåÑ‰∫ã‰ª∂(self.name, "ÊêçÂ§±", current_time, {"value": damage, "reason": "Falling Debris"})
            if self.health <= 0:
                self.curr_action = "Unconscious"
                return log_msg + " ‰ª£ÁêÜ‰∫∫Â∑≤Â§±ÂéªÊÑèË≠ò„ÄÇ"

        if not self.quake_has_taken_cover:
            self.quake_has_taken_cover = True
            self.target_place = self.curr_place
            self.curr_action = "Â∞ãÊâæÈÅÆËîΩÁâ©"
            self.current_thought = "‰øùÊåÅÂÜ∑ÈùúÔºåÂÖàÂ∞±ËøëÂ∞ãÊâæÊé©Ë≠∑„ÄÇ"
            self.disaster_experience_log.append("Â∞±Âú∞Êé©Ë≠∑‰ª•ÈÅøÂÖçÂèóÂÇ∑„ÄÇ")
            return f"{self.name} Ê≠£Âú®Â∞ãÊâæÊé©Ë≠∑ (HP:{self.health})„ÄÇ"

        if not self.quake_evacuation_started:
            self.quake_evacuation_started = True
            if self.target_place != "Subway":
                self.previous_place = self.curr_place
                self.target_place = "Subway"
                self.curr_place = self.find_path("Subway")
                if self.curr_place in PORTAL_CONNECTIONS and "Âú∞Èêµ" in self.curr_place:
                    self.teleport(self.curr_place)
            self.curr_action = "Êí§Èõ¢Âà∞Âú∞Èêµ"
            self.current_thought = "ÂæÄÂú∞ÈêµÈÅøÈõ£ÊúÉÊõ¥ÂÆâÂÖ®„ÄÇ"
            self.disaster_experience_log.append("ÈñãÂßãÊí§Èõ¢ÂâçÂæÄÂú∞ÈêµÈÅøÈõ£„ÄÇ")
            return f"{self.name} Ê≠£Âú®Êí§Èõ¢Âà∞Âú∞ÈêµÈÅøÈõ£ (HP:{self.health})„ÄÇ"

        if self.target_place == "Subway" and self.curr_place != "Subway":
            if self.curr_place in PORTAL_CONNECTIONS and "Âú∞Èêµ" in self.curr_place:
                self.teleport(self.curr_place)
                if self.curr_place == "Subway":
                    self.curr_action = "Âú®Âú∞ÈêµÈÅøÈõ£"
                    self.current_thought = "Â∑≤Á∂ìÊäµÈÅîÂú∞ÈêµÔºåÁπºÁ∫å‰øùÊåÅË≠¶Êàí„ÄÇ"
                    return f"{self.name} Â∑≤ÊäµÈÅîÂú∞ÈêµÈÅøÈõ£ (HP:{self.health})„ÄÇ"
            self.curr_action = "Êí§Èõ¢Âà∞Âú∞Èêµ"
            self.current_thought = "Ê≤øËëóË∑ØÁ∑öÂâçÂæÄÂú∞ÈêµÈÅøÈõ£„ÄÇ"
            return f"{self.name} Ê≠£Âú®ÂâçÂæÄÂú∞ÈêµÈÅøÈõ£ (HP:{self.health})„ÄÇ"

        # ‰ΩøÁî® LLM Ê±∫ÂÆö‰∏ã‰∏ÄÊ≠•Ë°åÂãï
        self._enter_thinking()
        try:
            new_action, new_thought = await llm.run_gpt_prompt_earthquake_step_action(
                self.persona_summary, self.health, self.mental_state, self.curr_place, intensity, self.disaster_experience_log[-5:]
            )
        finally:
            self._exit_thinking()
        self.curr_action = new_action
        self.current_thought = new_thought
        self.disaster_experience_log.append(f"Âú® {self.curr_place} Ê±∫ÂÆö {new_action}„ÄÇÂÖßÂøÉÊÉ≥Ê≥ï: {new_thought}")


        # Âü∑Ë°åÂπ´Âä©Ë°åÁÇ∫
        help_log = self.perceive_and_help(agents)
        if help_log:
            message = help_log.get("message")
            if message:
                self.disaster_experience_log.append(message)
            if disaster_logger:
                disaster_logger.Ë®òÈåÑ‰∫ã‰ª∂(self.name, "Âêà‰Ωú", current_time, help_log)

        return f"{self.name} Ê≠£Âú® {self.curr_action} (HP:{self.health})„ÄÇÊÉ≥Ê≥ï:„Äé{self.current_thought}„Äè"

    async def perform_recovery_step_action(self, agents, buildings, disaster_logger, current_time):
        """
        Âú®Âú∞ÈúáÂæåÁöÑÊÅ¢Âæ©ÈöéÊÆµÔºåÊ±∫ÂÆö‰∏¶Âü∑Ë°å‰ª£ÁêÜ‰∫∫ÁöÑË°åÂãï„ÄÇ
        """
        # ÂÑ™ÂÖàËôïÁêÜËá™ÊïëÊàñ‰∫íÊïë
        if self.is_injured:
            self.curr_action = "Â∞ãÊâæÈÜ´ÁôÇË≥áÊ∫êÊàñ‰ºëÊÅØ"
        else:
            help_log = self.perceive_and_help(agents)
            if help_log:
                self.curr_action = "Âπ´Âä©‰ªñ‰∫∫"
                message = help_log.get("message")
                if message:
                    self.disaster_experience_log.append(message)
                if disaster_logger:
                    disaster_logger.Ë®òÈåÑ‰∫ã‰ª∂(self.name, "Âêà‰Ωú", current_time, help_log)
            else:
                # Â¶ÇÊûúÊ≤íÊúâ‰∫∫ÈúÄË¶ÅÂπ´Âä©Ôºå‰ΩøÁî® LLM Ê±∫ÂÆöÊÅ¢Âæ©Ë°åÂãï
                self._enter_thinking()
                try:
                    self.curr_action = await llm.run_gpt_prompt_get_recovery_action(
                        self.persona_summary, self.mental_state, self.curr_place
                    )
                finally:
                    self._exit_thinking()
        
        log_msg = f"{self.name} Ê≠£Âú® {self.curr_action} (HP:{self.health})„ÄÇ"
        self.disaster_experience_log.append(log_msg)
        return log_msg